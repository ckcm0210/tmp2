# Excel Formula Tracer - 改進建議 (Tool Improvement Suggestions)

這是一份針對目前 Excel 公式追蹤工具 (v53) 的綜合改進建議。此工具目前的核心功能已非常強大，以下建議旨在從「效能」、「功能」和「體驗」三個層面，探討讓工具更上一層樓的可能性。

---

## 1. 關於 Polars 套件的評估

### 結論
Polars 是處理 **資料 (Values)** 的高效能函式庫，而此工具的核心是分析 **公式 (Formulas)**。因此，Polars **不能**直接取代 `openpyxl`，但可在特定環節**作為補充**以提升效能。

### 詳細分析
- **Polars 的強項**: 極快地讀取 Excel 中的**計算結果**到 DataFrame，適合大規模資料分析。
- **Polars 的弱項**: 完全忽略儲存格背後的公式字串，無法用於公式追蹤。
- **潛在協同作用**: 可考慮用 Polars 替代 `openpyxl.load_workbook(..., data_only=True)` 的環節，專門用來快速獲取所有儲存格的計算值，為主程式的公式分析提供數值對照，從而提升「獲取計算值」這一步的效能。

---

## 2. 綜合改進建議

### 第一層級：核心體驗與效能

#### 1.1 非同步處理與快取機制 (Asynchronous Processing & Caching)
- **使用者角度 (Why):** 處理大型 Excel 檔案時，UI 會卡頓甚至無回應。如果掃描能在背景執行，且結果能被快取，未來開啟同一個檔案將會非常迅速。
- **技術思路 (How):**
    - **背景執行**: 使用 `threading` 或 `asyncio` 將 `excel_scanner.py` 中的掃描任務放到背景執行緒，完成後透過回呼 (Callback) 或事件 (Event) 更新 UI，避免介面凍結。
    - **結果快取**: 首次掃描後，將結果連同檔案的「最後修改時間」儲存到一個 `.cache` 檔案中。下次載入時，若修改時間未變，則直接從快取讀取，跳過完整掃描。

#### 1.2 智慧的搜尋與篩選 (Smarter Search & Filter)
- **使用者角度 (Why):** 除了簡單的文字包含，我希望能用更複雜的規則來篩選，例如正規表示式 (Regex) 或多條件組合。
- **技術思路 (How):**
    - 在篩選輸入框旁增加一個模式切換按鈕（例如「純文字」/「Regex」）。
    - 在 `apply_filter` 函數中，根據所選模式，使用 `re.search()` 進行正規表示式匹配。
    - 可設計一個「進階篩選」彈出視窗，讓使用者用 AND/OR 組合多個篩選條件（如 `Type IS 'external link' AND Formula CONTAINS 'SUMIF'`）。

### 第二層級：強大的新功能

#### 2.1 視覺化依賴關係圖 (Visual Dependency Graph)
- **使用者角度 (Why):** 除了樹狀列表，一個網狀的、可以互動的關係圖能讓我更直觀地理解公式之間的複雜依賴關係，快速定位關鍵節點和循環參照。
- **技術思路 (How):**
    - 在「Explode」視窗中增加「視覺化圖表」按鈕。
    - 點擊後，利用 `dependency_tree_data` 的數據，整合 `pyvis` 或 `graphviz` 函式庫。
    - 遍歷節點，根據 `type`（公式/數值/外部連結）和 `depth` 設定不同的節點顏色、大小或形狀。
    - 將節點間的 `children` 關係繪製成箭頭。
    - 將生成的 HTML 圖表在新視窗或瀏覽器中展示。

#### 2.2 公式比對與變更追蹤 (Formula Comparison & Change Tracking)
- **使用者角度 (Why):** 我需要比較兩個版本的報表（例如，上個月 vs. 這個月），快速找出哪些公式或數值被修改了。
- **技術思路 (How):**
    - 完善現有的 `formula_comparator.py`。
    - 在 UI 提供「檔案比對」模式，讓使用者選擇兩個檔案。
    - 執行比對邏輯，找出儲存格在「公式內容」和「計算結果」上的差異。
    - 在新的 UI 介面中，並排或合併顯示兩個版本的資料，並用高亮（如紅色刪除、綠色新增、黃色修改）標示出差異點。

#### 2.3 錯誤檢查與健康度報告 (Error Checking & Health Report)
- **使用者角度 (Why):** 我想一鍵掃描出 Excel 中所有的潛在問題，例如 `#REF!`、`#N/A` 等錯誤，以及中斷的外部連結。
- **技術思路 (How):**
    - 在 `excel_scanner.py` 中增加錯誤檢查邏輯。
    - 遍歷儲存格時，檢查 `cell.value` 是否為 Excel 的標準錯誤類型。
    - 檢查外部連結的檔案路徑是否存在。
    - 提供一個「健康報告」功能，將所有發現的問題分類列表，並提供快速跳轉到問題儲存格的功能。

#### 2.4 連結管理與修復工具 (Link Management & Repair)
- **使用者角度 (Why):** 當我移動了被參照的 Excel 檔案位置後，所有指向它的公式都會壞掉。如果有一個工具能讓我批量尋找並修復這些中斷的連結，將會是救星。
- **技術思路 (How):**
    - 建立一個「連結管理」面板，掃描並列出所有外部連結及其狀態（正常/中斷）。
    - 允許使用者選取一個或多個中斷的連結，並指定新的正確檔案路徑。
    - 工具自動遍歷所有公式，將舊的路徑替換為新路徑。

### 第三層級：專業與進階功能

#### 3.1 支援使用者自訂函數 (UDF) 和命名範圍 (Named Ranges)
- **使用者角度 (Why):** 我的 Excel 中大量使用了自訂的 VBA 函數 (UDF) 和命名範圍，目前的工具無法解析它們的依賴關係。
- **技術思路 (How):**
    - **命名範圍**: `openpyxl` 可以透過 `workbook.defined_names` 讀取命名範圍。在公式解析前，建立一個命名範圍到其對應參照（如 `MyData` -> `Sheet1!$A$1:$B$10`）的映射表，並在解析時進行替換。
    - **UDF**: 這非常複雜。一個可行的方向是，解析 VBA 程式碼 (`workbook.vba_project.bin`)，找出 UDF 的函數簽名，並在 UI 中將其標示為「UDF」，雖然可能無法解析其內部的依賴關係，但至少能讓使用者知道這裡有一個自訂函數。

#### 3.2 影響性分析 (Impact Analysis / "What-If")
- **使用者角度 (Why):** 我想知道，如果我修改了儲存格 `A1`，到底會影響到哪些其他的儲存格？這對於評估修改帶來的風險至關重要。
- **技術思路 (How):**
    - 這是「依賴性分析」的逆向操作。需要建立一個「被誰參照」(Referenced-By) 的反向依賴圖。
    - 掃描時，除了記錄 `A1` 參照了誰，還要記錄 `B1`、`C1` 等儲存格參照了 `A1`。
    - 使用者選定一個儲存格後，工具遍歷這個反向圖，找出所有直接或間接依賴於此儲存格的其他儲存格，並以列表或視覺化圖表呈現。

### 第四層級：使用體驗與細節打磨

#### 4.1 語法高亮 (Syntax Highlighting)
- **使用者角度 (Why):** 在查看長公式時，如果函數、範圍、運算子能有不同的顏色，會更容易閱讀和理解。
- **技術思路 (How):**
    - 在顯示公式的 `tk.Text` 元件中，利用 `tag_add` 和 `tag_config` 功能。
    - 建立一個簡單的 Excel 公式解析器（或用正規表示式），識別出函數名（如 `VLOOKUP`）、範圍（如 `A1:B5`）、字串、數字和運算子。
    - 為不同類型的 token 設定不同的顏色和字體樣式。

#### 4.2 匯出分析結果 (Export Results)
- **使用者角度 (Why):** 我想將分析結果（例如公式列表、錯誤報告、依賴關係樹）匯出成 CSV 或 Excel 檔案，以便歸檔或與同事分享。
- **技術思路 (How):**
    - 在主介面和「Explode」視窗中增加「匯出」按鈕。
    - 將 `Treeview` 中的資料或分析結果整理成二維列表。
    - 使用 `csv` 或 `openpyxl` 函式庫，將資料寫入使用者指定的檔案中。

#### 4.3 儲存與載入工作階段 (Save/Load Session)
- **使用者角度 (Why):** 我花了很多時間設定篩選條件、排列欄位、開啟了好幾個「Explode」視窗。如果能將目前的工作狀態儲存下來，下次可以直接恢復，會非常方便。
- **技術思路 (How):**
    - 定義一個「工作階段」物件，用來儲存所有 UI 狀態（篩選文字、視窗位置、已開啟的分頁等）。
    - 提供「儲存工作階段」和「載入工作階段」的選單功能。
    - 使用 `pickle` 或 `json` 將這個物件序列化並儲存到檔案中。
